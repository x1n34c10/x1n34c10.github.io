---
sitemap: false
permalink: /whoami/
---

<div class="container">
  <div class="text">Hola, soy @WackyH4cker, entusiasta de la ciberseguridad y el hacking ético.</div>
  <p style="color:#fff"><i>Ser capaz de superar la seguridad no te convierte en un hacker, de la misma forma que hacer un puente a un coche no te convierte en ingeniero mecánico. Si tu empresa gasta más en café que en seguridad TI, serás hackeado. Es más, merecerás ser hackeado<i></p>
  <style>
    @import 'https://fonts.googleapis.com/css?family=Roboto+Mono:100';

html, body {
  font-family: 'Roboto Mono', monospace;
  background: #16191b;
  height: 100%;
}

.container {
  padding-top: 100px;
  max-width: 700px;
  width: 100%;
  margin: 0 auto;
}

.text {
  font-weight: 100;
  font-size: 18px;
  color: #e2e6e8;
}

.text-wrap {
  display: block;
  line-height: 1.6;
  opacity: 0;
  transform: translateX(-20px);
  transition: all 150ms ease-in;
  transition-delay: 150ms;
}

.text-wrap.active {
  transform: translateX(0);
  opacity: 1;
}

.d {
  color: #757575;
}
  </style>
</div>
<script>
  /*
 Inspired by https://soulwire.co.uk/
*/

const HyperText = el => {
	// Some configuration variables
  const START = 0;
  const END = 35;
  const STAGGER = 1.65;
  const RANDOM_CHAR = 0.25;
  const LINE_DELAY = 100;

	// Internal Text handler
  const _HyperText = el => {
    let frame = 0;

    const randomChar = () => {
      const chars = '!<>-_\\/[]{}—=+*^?#-----------------------------------------------------------------------------------------------';

      return chars[Math.floor(Math.random() * chars.length)]
    };

    const getScript = text => {
      return text.split('').reduce((arr, char, indx) => {
        const start = Math.floor(Math.random() * START) + (indx * STAGGER);
        const stop = start + Math.floor(Math.random() * END);

        arr.push({
          char,
          start,
          stop
        });

        return arr;
      }, []);
    };

    const animate = args => {
      let complete = 0;

      let {
        el,
        scripts,
        frame
      } = args;

      let output = scripts.reduce((html, script, indx) => {
        let {
          char,
          start,
          stop,
          currentChar
        } = script;

        if (frame >= stop) {
          complete++;
          html += char;
        } else if (frame >= start) {
          if (!currentChar || Math.random() < RANDOM_CHAR) {
            currentChar = randomChar();
            scripts[indx].currentChar = currentChar;
          }

          html += `<span class='d'>${currentChar}</span>`;
        } else {
          html += '';
        }

        return html;
      }, '');

      el.innerHTML = output;

      if (complete === scripts.length) {
        cancelAnimationFrame(raf);
      } else {
        frame++;
        raf = requestAnimationFrame(() => animate({
          el,
          scripts,
          frame
        }))
      }
    };

    const scripts = getScript(el.innerText);

    el.classList.add('active');

    let raf = requestAnimationFrame(() => animate({
      el,
      scripts,
      frame
    }));

    return true;
  }

  const getEachLine = text => {
    let newText = text.innerHTML.replace(/(\S+\s*)/g, '<span>$1</span>');
    text.innerHTML = newText;

    let spans = text.querySelectorAll('span');

    const consolidateWordsIntoLine = words => {
      let container = document.createElement('span');
      container.classList.add('text-wrap');

      return Array.from(words).reduce((line, span) => {
        line.innerText += span.innerText;

        return line;
      }, container);
    };

    const groupWordsByOffset = words => {
      return Array.from(words).reduce((map, word) => {
        let offset = word.offsetTop;

        if (!map.has(offset)) {
          map.set(offset, []);
        }

        map.get(offset).push(word);

        return map;
      }, new Map());
    };

    let wordMap = groupWordsByOffset(spans);

    text.innerHTML = '';

    wordMap.forEach(row => {
      let line = consolidateWordsIntoLine(row);

      text.appendChild(line)
    });

    return document.querySelectorAll('.text-wrap');
  };

  const eachLine = getEachLine(el);
  
  let delay = 0;
  
  return Array.from(eachLine).map(line => {
		delay += LINE_DELAY;
    return setTimeout(() => _HyperText(line), delay);
  });
}

let text = document.querySelector('.text');

HyperText(text);
</script>
